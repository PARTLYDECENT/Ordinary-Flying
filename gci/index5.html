<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    title>Quantum Shader Realm</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            border: 1px solid #0ff;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 6px;
            height: 6px;
            background-color: #0ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        #lore-note {
            position: absolute;
            bottom: 15%;
            width: 80%;
            left: 10%;
            text-align: center;
            z-index: 100;
            display: none;
            font-size: 1.1em;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            padding: 15px;
            box-sizing: border-box;
            background-color: rgba(0,0,0,0.5);
            border-radius: 5px;
            border: 1px solid #0ff;
        }
        #energy-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background-color: rgba(0,0,0,0.7);
            border: 1px solid #0ff;
            border-radius: 10px;
            overflow: hidden;
        }
        #energy-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ffff, #0080ff);
            transition: width 0.3s;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">
        Use WASD to move, mouse to look around. Find the energy nodes to recharge.
    </div>
    <div id="crosshair"></div>
    <div id="lore-note"></div>
    <div id="energy-bar">
        <div id="energy-fill"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Basic Setup ---
        let scene, camera, renderer;
        let clock = new THREE.Clock();
        let floor, ceiling, wall1, wall2, wall3, wall4;
        let materials = {};
        let portalsGroup;
        let energyNodes = [];
        
        // --- World State ---
        let currentWorldId = 'quantum_nexus';
        let isTeleporting = false;
        let energyLevel = 100;
        let energyDrainRate = 2; // Energy drain per second
        
        // --- Movement & Controls ---
        let controls = { moveForward: false, moveBackward: false, moveLeft: false, moveRight: false };
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        const moveSpeed = 30.0;
        const lookSpeed = 0.002;
        
        // --- Shaders ---
        const vertexShader = `
            varying vec2 vUv;
            varying vec3 vPosition;
            void main() {
                vUv = uv;
                vPosition = position;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        // --- Fragment Shaders ---
        const quantumFloorShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
            }
            
            void main() {
                vec2 uv = vUv * 8.0;
                float t = time * 0.2;
                
                // Create grid pattern
                vec2 grid = fract(uv);
                float line = smoothstep(0.0, 0.05, grid.x) * smoothstep(0.0, 0.05, grid.y);
                line *= smoothstep(0.95, 1.0, grid.x) * smoothstep(0.95, 1.0, grid.y);
                
                // Animated energy flow
                float flow = sin(uv.x * 2.0 + t) * sin(uv.y * 2.0 + t);
                flow = smoothstep(0.0, 0.5, flow);
                
                vec3 color = mix(vec3(0.0, 0.05, 0.2), vec3(0.0, 0.3, 0.5), line);
                color = mix(color, vec3(0.0, 0.8, 0.8), flow * 0.5);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        const quantumWallShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
            }
            
            void main() {
                vec2 uv = vUv;
                float t = time * 0.1;
                
                // Base color
                vec3 baseColor = vec3(0.05, 0.0, 0.1);
                
                // Circuit pattern
                vec2 circuitUV = uv * 20.0;
                vec2 circuitPos = fract(circuitUV);
                float circuit = step(0.95, circuitPos.x) + step(0.95, circuitPos.y);
                
                // Animated pulses
                float pulse = sin(length(uv - 0.5) * 10.0 - t * 3.0);
                pulse = smoothstep(0.0, 0.2, pulse);
                
                vec3 color = mix(baseColor, vec3(0.0, 0.5, 0.8), circuit);
                color = mix(color, vec3(0.5, 0.0, 0.8), pulse);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        const dataStreamShader = `
            uniform float time;
            varying vec2 vUv;
            
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }
            
            void main() {
                vec2 st = vUv;
                st.y += time * 0.2; // Scroll down
                
                vec3 color = vec3(0.0, 0.0, 0.05);
                
                // Create data streams
                for(float i = 0.0; i < 20.0; i++) {
                    vec2 pos = vec2(fract(i * 0.137), fract(st.y + i * 0.1));
                    float data = random(vec2(i, floor(st.y * 20.0 + i * 0.1)));
                    
                    if(data > 0.7) {
                        float brightness = (data - 0.7) * 3.333;
                        color += vec3(0.0, brightness, brightness * 0.5) * 
                                (1.0 - distance(st.x, pos.x) * 5.0);
                    }
                }
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        const voidShader = `
            uniform float time;
            varying vec2 vUv;
            
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);
            }
            
            void main() {
                vec2 uv = vUv;
                float t = time * 0.05;
                
                // Create swirling void effect
                vec2 center = vec2(0.5, 0.5);
                vec2 pos = uv - center;
                float dist = length(pos);
                float angle = atan(pos.y, pos.x);
                
                // Swirl effect
                angle += dist * 5.0 - t;
                pos = vec2(cos(angle), sin(angle)) * dist;
                
                // Noise pattern
                float n = noise(pos * 10.0 + t);
                
                // Color based on distance and noise
                vec3 color = mix(vec3(0.0, 0.0, 0.1), vec3(0.2, 0.0, 0.3), n);
                color *= (1.0 - smoothstep(0.0, 0.7, dist));
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        const crystalShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vec2 uv = vUv;
                float t = time * 0.3;
                
                // Crystal-like refraction pattern
                vec2 p = uv * 2.0 - 1.0;
                float a = atan(p.y, p.x);
                float r = length(p);
                
                // Refraction effect
                float refraction = sin(a * 6.0 + t) * 0.1;
                r += refraction;
                
                // Crystal facets
                float facets = sin(a * 3.0) * cos(r * 10.0 + t);
                facets = smoothstep(0.0, 0.5, facets);
                
                // Color gradient
                vec3 color = mix(vec3(0.8, 0.2, 0.9), vec3(0.2, 0.8, 0.9), facets);
                color *= (1.0 - r * 0.5);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        const portalShader = `
            uniform float time;
            varying vec2 vUv;
            
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }
            
            void main() {
                vec2 st = vUv;
                float t = time * 0.5;
                
                // Create portal effect
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(st, center);
                
                // Portal ring
                float ring = smoothstep(0.45, 0.4, dist) - smoothstep(0.4, 0.35, dist);
                
                // Energy particles
                float particles = 0.0;
                for(float i = 0.0; i < 20.0; i++) {
                    vec2 particlePos = vec2(
                        0.5 + sin(t + i * 0.314) * 0.4,
                        0.5 + cos(t + i * 0.314) * 0.4
                    );
                    particles += 0.05 / distance(st, particlePos);
                }
                
                // Glowing effect
                vec3 color = vec3(0.0, 0.8, 1.0) * ring;
                color += vec3(0.5, 1.0, 1.0) * particles;
                
                // Fade at edges
                float alpha = ring + particles * 0.5;
                alpha *= smoothstep(0.5, 0.3, dist);
                
                gl_FragColor = vec4(color, alpha);
            }
        `;
        
        const energyNodeShader = `
            uniform float time;
            varying vec2 vUv;
            varying vec3 vPosition;
            
            void main() {
                vec2 uv = vUv;
                float t = time * 2.0;
                
                // Pulsing energy core
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(uv, center);
                
                // Pulsing effect
                float pulse = sin(t) * 0.1 + 0.9;
                
                // Energy core
                float core = 1.0 - smoothstep(0.0, 0.3 * pulse, dist);
                
                // Energy glow
                float glow = 1.0 - smoothstep(0.0, 0.5 * pulse, dist);
                
                // Color
                vec3 color = vec3(1.0, 1.0, 0.0) * core;
                color += vec3(0.5, 1.0, 0.0) * glow * 0.5;
                
                gl_FragColor = vec4(color, core + glow * 0.5);
            }
        `;
        
        // --- World Data ---
        const worlds = {
            'quantum_nexus': {
                shaders: { 
                    floor: 'quantum_floor', 
                    ceiling: 'data_stream', 
                    wall1: 'quantum_wall', 
                    wall2: 'quantum_wall', 
                    wall3: 'quantum_wall', 
                    wall4: 'quantum_wall' 
                },
                portals: [
                    { 
                        triggerBox: new THREE.Box3(new THREE.Vector3(-10, 0, -55), new THREE.Vector3(10, 20, -45)), 
                        toWorld: 'void_chamber', 
                        entryPoint: new THREE.Vector3(0, 5, 80),
                        position: new THREE.Vector3(0, 10, -49.9),
                        rotation: new THREE.Euler(0, 0, 0),
                        size: new THREE.Vector2(20, 20)
                    }
                ],
                energyNodes: [
                    { position: new THREE.Vector3(30, 5, 30), collected: false },
                    { position: new THREE.Vector3(-30, 5, 30), collected: false },
                    { position: new THREE.Vector3(0, 5, -30), collected: false }
                ],
                lore: [
                    { box: new THREE.Box3(new THREE.Vector3(-5, 0, 5), new THREE.Vector3(5, 10, 15)), 
                      text: "The quantum realm is unstable. Energy nodes are required for stabilization." }
                ]
            },
            'void_chamber': {
                shaders: { 
                    floor: 'void', 
                    ceiling: 'void', 
                    wall1: 'void', 
                    wall2: 'void', 
                    wall3: 'void', 
                    wall4: 'void' 
                },
                portals: [
                    { 
                        triggerBox: new THREE.Box3(new THREE.Vector3(-10, 0, 95), new THREE.Vector3(10, 20, 105)), 
                        toWorld: 'crystal_garden', 
                        entryPoint: new THREE.Vector3(0, 5, 0),
                        position: new THREE.Vector3(0, 10, 99.9),
                        rotation: new THREE.Euler(0, Math.PI, 0),
                        size: new THREE.Vector2(20, 20)
                    }
                ],
                energyNodes: [
                    { position: new THREE.Vector3(40, 5, 40), collected: false },
                    { position: new THREE.Vector3(-40, 5, -40), collected: false }
                ],
                lore: [
                    { box: new THREE.Box3(new THREE.Vector3(20, 0, 20), new THREE.Vector3(40, 10, 40)), 
                      text: "The void consumes all energy. Find the nodes before it's too late." }
                ]
            },
            'crystal_garden': {
                shaders: { 
                    floor: 'crystal', 
                    ceiling: 'crystal', 
                    wall1: 'crystal', 
                    wall2: 'crystal', 
                    wall3: 'crystal', 
                    wall4: 'crystal' 
                },
                portals: [
                    { 
                        triggerBox: new THREE.Box3(new THREE.Vector3(-10, 0, -10), new THREE.Vector3(10, 20, 10)), 
                        toWorld: 'quantum_nexus', 
                        entryPoint: new THREE.Vector3(0, 5, 0),
                        position: new THREE.Vector3(0, 10, 0),
                        rotation: new THREE.Euler(0, 0, 0),
                        size: new THREE.Vector2(20, 20)
                    }
                ],
                energyNodes: [
                    { position: new THREE.Vector3(30, 5, 0), collected: false },
                    { position: new THREE.Vector3(-30, 5, 0), collected: false },
                    { position: new THREE.Vector3(0, 5, 30), collected: false },
                    { position: new THREE.Vector3(0, 5, -30), collected: false }
                ],
                lore: [
                    { box: new THREE.Box3(new THREE.Vector3(-15, 0, -15), new THREE.Vector3(15, 10, 15)), 
                      text: "The crystals resonate with quantum energy. They can replenish your reserves." }
                ]
            }
        };
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);
            scene.fog = new THREE.Fog(0x000510, 0, 150);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // --- Create all materials ---
            const createShaderMaterial = (fs, transparent = false) => new THREE.ShaderMaterial({
                uniforms: { time: { value: 0.0 } },
                vertexShader: vertexShader,
                fragmentShader: fs,
                transparent: transparent,
                depthWrite: !transparent
            });
            
            materials.quantum_floor = createShaderMaterial(quantumFloorShader);
            materials.quantum_wall = createShaderMaterial(quantumWallShader);
            materials.data_stream = createShaderMaterial(dataStreamShader);
            materials.void = createShaderMaterial(voidShader);
            materials.crystal = createShaderMaterial(crystalShader);
            materials.portal = createShaderMaterial(portalShader, true);
            materials.energy_node = createShaderMaterial(energyNodeShader, true);
            
            // --- Create world geometry ---
            const planeSize = 200;
            const floorGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
            const wallGeometry = new THREE.PlaneGeometry(planeSize, planeSize / 2);
            
            floor = new THREE.Mesh(floorGeometry);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);
            
            ceiling = new THREE.Mesh(floorGeometry);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = planeSize / 2;
            scene.add(ceiling);
            
            wall1 = new THREE.Mesh(wallGeometry);
            wall1.position.set(0, planeSize / 4, -planeSize / 2);
            scene.add(wall1);
            
            wall2 = new THREE.Mesh(wallGeometry);
            wall2.position.set(-planeSize / 2, planeSize / 4, 0);
            wall2.rotation.y = Math.PI / 2;
            scene.add(wall2);
            
            wall3 = new THREE.Mesh(wallGeometry);
            wall3.position.set(planeSize / 2, planeSize / 4, 0);
            wall3.rotation.y = -Math.PI / 2;
            scene.add(wall3);
            
            wall4 = new THREE.Mesh(wallGeometry);
            wall4.position.set(0, planeSize / 4, planeSize / 2);
            wall4.rotation.y = Math.PI;
            scene.add(wall4);
            
            // --- Create portal group ---
            portalsGroup = new THREE.Group();
            scene.add(portalsGroup);
            
            // --- Create energy nodes group ---
            energyNodes = [];
            
            // --- Load initial world ---
            loadWorld('quantum_nexus');
            
            // --- Event Listeners ---
            document.addEventListener('click', () => document.body.requestPointerLock());
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function loadWorld(worldId) {
            if (!worlds[worldId]) return;
            currentWorldId = worldId;
            const worldData = worlds[worldId];
            
            // Update materials
            floor.material = materials[worldData.shaders.floor];
            ceiling.material = materials[worldData.shaders.ceiling];
            wall1.material = materials[worldData.shaders.wall1];
            wall2.material = materials[worldData.shaders.wall2];
            wall3.material = materials[worldData.shaders.wall3];
            wall4.material = materials[worldData.shaders.wall4];
            
            // Clear old portals and create new ones
            while (portalsGroup.children.length > 0) {
                portalsGroup.remove(portalsGroup.children[0]);
            }
            
            if (worldData.portals) {
                for (const portalData of worldData.portals) {
                    const portalGeometry = new THREE.PlaneGeometry(portalData.size.x, portalData.size.y);
                    const portalMesh = new THREE.Mesh(portalGeometry, materials.portal);
                    portalMesh.position.copy(portalData.position);
                    portalMesh.rotation.copy(portalData.rotation);
                    portalsGroup.add(portalMesh);
                }
            }
            
            // Clear old energy nodes and create new ones
            while (energyNodes.length > 0) {
                scene.remove(energyNodes.pop());
            }
            
            if (worldData.energyNodes) {
                for (const nodeData of worldData.energyNodes) {
                    if (!nodeData.collected) {
                        const nodeGeometry = new THREE.SphereGeometry(3, 32, 32);
                        const nodeMesh = new THREE.Mesh(nodeGeometry, materials.energy_node);
                        nodeMesh.position.copy(nodeData.position);
                        nodeMesh.userData = nodeData;
                        scene.add(nodeMesh);
                        energyNodes.push(nodeMesh);
                    }
                }
            }
        }
        
        function checkPortals() {
            if (isTeleporting) return;
            const worldData = worlds[currentWorldId];
            if (!worldData.portals) return;
            
            for (const portal of worldData.portals) {
                if (portal.triggerBox.containsPoint(camera.position)) {
                    isTeleporting = true;
                    document.body.style.transition = 'opacity 0.5s';
                    document.body.style.opacity = 0;
                    
                    setTimeout(() => {
                        camera.position.copy(portal.entryPoint);
                        loadWorld(portal.toWorld);
                        document.body.style.opacity = 1;
                        setTimeout(() => { isTeleporting = false; }, 500);
                    }, 500);
                    break;
                }
            }
        }
        
        function checkEnergyNodes() {
            for (let i = energyNodes.length - 1; i >= 0; i--) {
                const node = energyNodes[i];
                const distance = camera.position.distanceTo(node.position);
                
                if (distance < 10) {
                    // Collect energy node
                    scene.remove(node);
                    energyNodes.splice(i, 1);
                    
                    // Replenish energy
                    energyLevel = Math.min(100, energyLevel + 25);
                    updateEnergyBar();
                    
                    // Mark as collected in world data
                    const worldData = worlds[currentWorldId];
                    for (const nodeData of worldData.energyNodes) {
                        if (nodeData.position.equals(node.position)) {
                            nodeData.collected = true;
                            break;
                        }
                    }
                }
            }
        }
        
        function updateEnergyBar() {
            const energyFill = document.getElementById('energy-fill');
            energyFill.style.width = energyLevel + '%';
        }
        
        const loreNoteElement = document.getElementById('lore-note');
        let currentLoreText = '';
        
        function checkLore() {
            const worldData = worlds[currentWorldId];
            let inLoreZone = false;
            if (worldData.lore) {
                for (const lore of worldData.lore) {
                    if (lore.box.containsPoint(camera.position)) {
                        inLoreZone = true;
                        if (currentLoreText !== lore.text) {
                            loreNoteElement.innerText = lore.text;
                            loreNoteElement.style.display = 'block';
                            currentLoreText = lore.text;
                        }
                        break;
                    }
                }
            }
            if (!inLoreZone && currentLoreText !== '') {
                loreNoteElement.style.display = 'none';
                currentLoreText = '';
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Update all shader uniforms
            for (const key in materials) {
                materials[key].uniforms.time.value = time;
            }
            
            // Drain energy over time
            energyLevel = Math.max(0, energyLevel - energyDrainRate * delta);
            updateEnergyBar();
            
            // Update movement
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            direction.z = Number(controls.moveForward) - Number(controls.moveBackward);
            direction.x = Number(controls.moveRight) - Number(controls.moveLeft);
            direction.normalize();
            if (controls.moveForward || controls.moveBackward) velocity.z -= direction.z * moveSpeed * delta;
            if (controls.moveLeft || controls.moveRight) velocity.x -= direction.x * moveSpeed * delta;
            camera.translateX(-velocity.x * delta);
            camera.translateZ(velocity.z * delta);
            camera.position.y = 5;
            
            // Check for interactions
            checkPortals();
            checkEnergyNodes();
            checkLore();
            
            renderer.render(scene, camera);
        }
        
        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX * lookSpeed;
                camera.rotation.x -= event.movementY * lookSpeed;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': controls.moveForward = true; break;
                case 'KeyA': controls.moveLeft = true; break;
                case 'KeyS': controls.moveBackward = true; break;
                case 'KeyD': controls.moveRight = true; break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': controls.moveForward = false; break;
                case 'KeyA': controls.moveLeft = false; break;
                case 'KeyS': controls.moveBackward = false; break;
                case 'KeyD': controls.moveRight = false; break;
            }
        }
        
        init();
        animate();
    </script>
</body>
</html>