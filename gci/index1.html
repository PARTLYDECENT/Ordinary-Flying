<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ORDINARY//ACCESS.PANEL//</title>
  <base href="https://partlydecent.github.io/ORDINARY-TECHNOLOGY/" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600&display=swap" rel="stylesheet">

  <meta property="og:title" content="SYSTEM CORE INTERFACE // ECHO_7">
  <meta property="og:description" content="Accessing anomalous data stream. Status: Uncertain.">
  <meta property="og:image" content="https://partlydecent.github.io/ORDINARY-TECHNOLOGY/banner.jpg">
  <meta property="og:image:alt" content="System Core Interface">
  <meta property="og:image:type" content="image/jpeg">
  <meta property="og:url" content="https://partlydecent.github.io/ORDINARY-TECHNOLOGY/">
  <meta property="og:type" content="website">

  <meta property="og:video" content="https://partlydecent.github.io/ORDINARY-TECHNOLOGY/glitch.mp4">
  <meta property="og:video:type" content="video/mp4">
  <meta property="og:video:secure_url" content="https://partlydecent.github.io/ORDINARY-TECHNOLOGY/glitch.mp4">
  <meta property="og:video:width" content="1200">
  <meta property="og:video:height" content="630">
  <meta property="og:video:aspect_ratio" content="1.91:1">

  <meta name="twitter:card" content="player">
  <meta name="twitter:player" content="https://partlydecent.github.io/ORDINARY-TECHNOLOGY/glitch.mp4">
  <meta name="twitter:player:width" content="1200">
  <meta name="twitter:player:height" content="630">

  <style>
    :root {
      --primary: #6A00FF; /* Deep Purple */
      --secondary: #00FFCC; /* Bright Cyan/Turquoise */
      --tertiary: #00B8D4; /* Vibrant Cyan/Teal */
      --background: #050511;
      --text: #FFFFFF;
      --unsettling-green: #306d3f; /* Added for shader */
      --deep-red: #7a0b2f;     /* Added for shader */

      --rgb-primary: 106, 0, 255;
      --rgb-secondary: 0, 255, 204;
      --rgb-tertiary: 0, 184, 212;
      --rgb-unsettling-green: 48, 109, 63;
      --rgb-deep-red: 122, 11, 47;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Space Grotesk', sans-serif;
      background-color: var(--background);
      color: var(--text);
      overflow-x: hidden;
      overflow-y: auto;
    }

    #webglCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }

    .noise-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1KrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==');
      opacity: 0.03;
      z-index: -1;
      pointer-events: none;
    }

    /* Banner and GIF Styling */
    .banner-container { /* Renamed from inline style */
        position: relative;
        width: 100%;
        max-width: 100%;
        overflow: hidden;
    }
    .banner-image { /* Renamed from inline style */
        width: 100%;
        display: block;
    }
    #glitchGif {
      position: absolute;
      bottom: 10px;
      right: 10px;
      width: 200px; /* Adjust size if needed */
      height: auto;
      mix-blend-mode: screen; /* Or 'difference', 'exclusion' for uncanny effects */
      opacity: 0.7; /* Slightly less opaque */
      pointer-events: none;
      filter: contrast(1.2) brightness(1.1); /* Enhance glitch effect */
    }

    .container {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      position: relative;
      z-index: 1;
      padding-bottom: 8rem; /* Ensure space above fixed console */
    }

    h1 {
      font-size: clamp(2rem, 5vw, 3.5rem);
      text-align: center;
      letter-spacing: 3px;
      line-height: 1.3;
      font-weight: 600;
      margin-bottom: 0.5rem;
      background: linear-gradient(to right, var(--secondary), var(--primary), var(--secondary), var(--tertiary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-size: 300% auto;
      animation:
        textGlowRevised 5s ease-in-out infinite alternate, /* Alternate direction */
        gradientShift 10s linear infinite; /* Slower gradient shift */
      text-shadow:
        0 0 4px rgba(var(--rgb-secondary), 0.3),
        0 0 10px rgba(var(--rgb-primary), 0.2);
    }

    /* Style for the second H1 */
    h1:nth-of-type(2) {
        font-size: clamp(1.5rem, 3vw, 2.5rem);
        margin-bottom: 2rem; /* Reduced margin */
        font-weight: 400; /* Lighter weight */
        opacity: 0.85;
        animation-delay: 0.5s; /* Start animations slightly later */
    }

    .beta {
        font-size: 0.8rem;
        font-weight: 600;
        letter-spacing: 3px;
        text-transform: uppercase;
        color: var(--secondary);
        background: rgba(var(--rgb-secondary), 0.1);
        padding: 0.3rem 0.8rem;
        border-radius: 4px;
        border: 1px solid rgba(var(--rgb-secondary), 0.3);
        margin-bottom: 3rem;
        animation: betaPulseRevised 2.5s infinite ease-in-out; /* Use revised animation */
        position: relative; /* Needed for potential pseudo-elements */
        display: inline-block; /* Fit content */
    }


    @keyframes textGlowRevised {
      0%, 100% {
        filter: drop-shadow(0 0 6px rgba(var(--rgb-secondary), 0.5)) drop-shadow(0 0 12px rgba(var(--rgb-secondary), 0.2));
      }
      50% {
        filter: drop-shadow(0 0 8px rgba(var(--rgb-primary), 0.6)) drop-shadow(0 0 16px rgba(var(--rgb-primary), 0.3));
      }
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* Revised Beta Pulse with color shift */
    @keyframes betaPulseRevised {
        0% {
            box-shadow: 0 0 10px rgba(var(--rgb-secondary), 0.6);
            border-color: rgba(var(--rgb-secondary), 0.3);
            transform: scale(1);
        }
        50% {
            box-shadow: 0 0 18px rgba(var(--rgb-tertiary), 0.8); /* Pulse with tertiary */
            border-color: rgba(var(--rgb-tertiary), 0.5);
            transform: scale(1.06); /* Slightly larger scale */
        }
        100% {
            box-shadow: 0 0 10px rgba(var(--rgb-secondary), 0.6);
            border-color: rgba(var(--rgb-secondary), 0.3);
            transform: scale(1);
        }
    }

    .button-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.5rem;
      width: 100%;
      max-width: 800px;
    }

    .button {
      background: rgba(10, 10, 20, 0.3); /* Darker base */
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.08); /* More subtle border */
      color: var(--text);
      padding: 1.2rem;
      font-size: 0.95rem; /* Slightly smaller font */
      letter-spacing: 1.5px; /* More spacing */
      text-transform: uppercase;
      border-radius: 6px; /* Sharper corners */
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      font-family: 'Space Grotesk', sans-serif;
      font-weight: 400;
      text-align: center;
    }

    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%; /* Start off-screen */
      width: 100%;
      height: 100%;
      /* Glitchy gradient sheen */
      background: linear-gradient(60deg, transparent, rgba(var(--rgb-secondary), 0.15), transparent, rgba(var(--rgb-primary), 0.1), transparent);
      transform: skewX(-25deg); /* Skew the sheen */
      transition: left 0.7s cubic-bezier(0.25, 1, 0.5, 1); /* Slower, smoother easing */
      opacity: 0.7;
    }

    .button:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.3);
      border-color: rgba(var(--rgb-secondary), 0.4); /* Highlight border */
    }

    .button:hover::before {
      left: 100%; /* Move sheen across */
    }

    .button:active {
        transform: translateY(-1px) scale(0.98); /* Press effect */
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
    }

    .play-button {
      border-left: 3px solid var(--secondary);
    }
    /* AI button uses tertiary color accent */
    .ai-button {
        border-left: 3px solid var(--tertiary);
        background: linear-gradient(45deg, rgba(var(--rgb-tertiary), 0.1), rgba(10, 10, 20, 0.3));
    }


    /* --- Console Styles --- */
    .console {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 1.5rem 0;
      display: flex;
      justify-content: center;
      z-index: 10;
      pointer-events: none;
      background: linear-gradient(to top, rgba(5, 5, 17, 0.9), transparent); /* Stronger gradient */
    }

    #consoleInput {
      width: 90%;
      max-width: 800px;
      padding: 1rem 1.5rem;
      background: rgba(0, 0, 0, 0.7); /* Darker console */
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px; /* Match buttons */
      color: var(--text);
      font-family: 'Space Grotesk', monospace;
      font-size: 1rem;
      letter-spacing: 1px;
      box-shadow: 0 4px 25px rgba(0, 0, 0, 0.4);
      transition: all 0.3s ease;
      pointer-events: auto;
    }

    #consoleInput::placeholder {
       color: rgba(255, 255, 255, 0.4); /* Dimmer placeholder */
       font-style: italic;
     }

    #consoleInput:focus {
      outline: none;
      border-color: var(--secondary);
      box-shadow: 0 0 0 2px rgba(var(--rgb-secondary), 0.2), 0 4px 25px rgba(0, 0, 0, 0.5); /* Adjusted focus shadow */
    }

    /* === INTERACTIVE SHOWCASE STYLES === */
    #interactive-showcase {
        max-width: 1200px;
        margin: 5rem auto; /* Increased margin */
        padding: 2rem;
        position: relative;
        z-index: 1;
        padding-bottom: 10rem; /* More padding to clear console */
    }

    #interactive-showcase h2 {
        font-size: clamp(1.8rem, 4vw, 2.8rem); /* Slightly smaller */
        text-align: center;
        letter-spacing: 2.5px;
        line-height: 1.2;
        font-weight: 600;
        margin-bottom: 3.5rem; /* More space */
        background: linear-gradient(to right, var(--tertiary), var(--primary), var(--secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: textGlow 8s ease-in-out infinite alternate; /* Alternate glow */
        opacity: 0.9;
    }

    .showcase-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 2.5rem; /* Increased gap */
    }

    .showcase-item {
        background: rgba(15, 15, 30, 0.4); /* Slightly lighter, bluer bg */
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.07);
        border-radius: 8px; /* Slightly rounder */
        overflow: hidden;
        transition: transform 0.4s ease, box-shadow 0.4s ease, border-color 0.4s ease;
        cursor: pointer;
        display: flex;
        flex-direction: column;
    }

    .showcase-item:hover {
        transform: translateY(-10px) scale(1.03); /* More pronounced hover */
        box-shadow: 0 18px 35px rgba(0, 0, 0, 0.35), 0 0 30px rgba(var(--rgb-tertiary), 0.25); /* Tertiary glow on hover */
        border-color: rgba(var(--rgb-tertiary), 0.5);
    }

     .showcase-image {
        width: 100%;
        aspect-ratio: 16 / 9;
        background-color: rgba(255, 255, 255, 0.03); /* Darker placeholder */
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
    }

    .showcase-image img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: transform 0.6s ease, opacity 0.6s ease, filter 0.6s ease;
        opacity: 0.8;
        filter: grayscale(20%); /* Slightly desaturated */
    }

    .showcase-item:hover .showcase-image img {
        transform: scale(1.12); /* Stronger zoom */
        opacity: 1;
        filter: grayscale(0%);
    }

    .showcase-image::before { /* Placeholder pulse */
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(circle, rgba(var(--rgb-tertiary), 0.1), transparent 70%);
        animation: pulsePlaceholder 3.5s infinite ease-in-out;
        opacity: 0;
        transition: opacity 0.5s ease;
    }

    .showcase-item:hover .showcase-image::before {
        opacity: 0.8; /* More visible pulse on hover */
    }

    .showcase-content {
        padding: 1.8rem; /* More padding */
        flex-grow: 1;
        display: flex;
        flex-direction: column;
    }

    .showcase-title {
        font-size: 1.3rem; /* Larger title */
        font-weight: 600;
        margin-bottom: 0.8rem;
        color: var(--tertiary); /* Use tertiary color */
        letter-spacing: 1px;
    }

    .showcase-description {
        font-size: 0.9rem;
        line-height: 1.7; /* Increased line height */
        color: rgba(255, 255, 255, 0.75); /* Slightly dimmer text */
        flex-grow: 1;
        margin-bottom: 1.2rem;
    }

    .showcase-button {
        background: transparent;
        border: 1px solid var(--primary); /* Primary color border */
        color: var(--primary);
        padding: 0.7rem 1.4rem;
        font-size: 0.8rem; /* Smaller button text */
        letter-spacing: 1.5px; /* More spacing */
        text-transform: uppercase;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-top: auto;
        align-self: flex-start;
        font-weight: 600; /* Bolder */
    }

    .showcase-button:hover {
        background: var(--primary);
        color: var(--background);
        box-shadow: 0 0 18px rgba(var(--rgb-primary), 0.5);
    }
    /* === END SHOWCASE STYLES === */

    /* Warp effect */
    .warp-distortion {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle, transparent 10%, black 90%); /* Tighter center */
      opacity: 0;
      z-index: 100;
      animation: warpEffect 1.2s cubic-bezier(0.6, -0.28, 0.735, 0.045); /* Faster, sharper ease */
      pointer-events: none;
    }

    @keyframes warpEffect {
      0% { opacity: 0; transform: scale(0); }
      40% { opacity: 0.9; transform: scale(1.6); } /* Faster peak */
      100% { opacity: 0; transform: scale(2.2); } /* Wider end */
    }

    /* Base text glow for showcase title */
    @keyframes textGlow {
      0%, 100% { filter: drop-shadow(0 0 8px rgba(var(--rgb-primary), 0.4)); }
      25% { filter: drop-shadow(0 0 12px rgba(var(--rgb-secondary), 0.5)); }
      50% { filter: drop-shadow(0 0 8px rgba(var(--rgb-tertiary), 0.4)); }
      75% { filter: drop-shadow(0 0 12px rgba(var(--rgb-primary), 0.5)); }
    }

    /* Particle Styles */
    .floating-particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }

    .particle {
      position: absolute;
      width: 4px; /* Default size */
      height: 4px;
      border-radius: 50%;
      background: var(--secondary); /* Default color */
      opacity: 0.6; /* Default opacity */
      /* Animation defined in JS */
    }

     /* Keyframes for console notification */
    @keyframes fadeIn { from { opacity: 0; transform: translateY(15px) translateX(-50%); } to { opacity: 1; transform: translateY(0) translateX(-50%); } }
    @keyframes fadeOut { from { opacity: 1; transform: translateY(0) translateX(-50%); } to { opacity: 0; transform: translateY(15px) translateX(-50%); } }

    /* Keyframes for showcase placeholder pulse */
    @keyframes pulsePlaceholder {
        0%, 100% { transform: scale(0.9); opacity: 0.4; }
        50% { transform: scale(1.1); opacity: 0.7; }
    }

  </style>
</head>

<body>
  <script src="sound-manager.js"></script>
  <canvas id="webglCanvas"></canvas>
  <div class="noise-overlay"></div>
  <div class="floating-particles" id="particles"></div>

  <div class="banner-container">
     <img src="https://partlydecent.github.io/ORDINARY-TECHNOLOGY/banner.jpg" alt="Ordinary Technology Banner" class="banner-image">
     <img id="glitchGif" src="https://partlydecent.github.io/ORDINARY-TECHNOLOGY/glitch.gif" alt="Glitching Overlay">
  </div>

  <div class="container">
    <h1>//ORDINARY//ACCESS.PANEL//</h1>
    <h1>//BUILDING THE FUTURE</h1></h1>
    <div class="beta">BETA 2.8 ::2026 VIBES </div> <div class="button-container">
      <button class="button play-button" onclick="navigateToGame()">ENTER GAMES</button>
      <button class="button play-button" onclick="navigateToVideoPlayer()">XENOPLAYER</button> <button class="button play-button" onclick="navigateToLiquidMusic()">AUDIO STREAM</button> <button class="button play-button" onclick="navigateToDimension88()">DIMENSION 88</button>
      <button class="button ai-button" onclick="navigateToAI()">ENVIROMENT GENERATOR .PLY</button> <button class="button play-button" onclick="navigateToSettings()">CALIBRATION</button> <button class="button play-button" onclick="navigateToForum()">WEAPON LAB [RESTRICTED]</button> <button class="button play-button" onclick="navigateToStore()">ACQUISITIONS</button> <button class="button play-button" onclick="navigateToAbout()">SYSTEM INFO</button> </div>
  </div>

  <section id="interactive-showcase">
      <h2>SYSTEM MODULES :: ACCESS GRANTED</h2> <div class="showcase-grid">
          <div class="showcase-item" onclick="handleShowcaseClick('feed_alpha')">
              <div class="showcase-image">
                  <img src="advert4.jpg" alt="Placeholder for Primary Feed">
              </div>
              <div class="showcase-content">
                  <h3 class="showcase-title">THE GOAL IS TO CHANGE THE WORLD ONE STEP AT A TIME. (RECYCLING)</h3>
                  <p class="showcase-description">H.D.P.E IS FULLY RECYCLABLE AND SO IS TIN AND ALUMINUM.</p>
                  <button class="showcase-button">Interface</button>
              </div>
          </div>
          <div class="showcase-item" onclick="handleShowcaseClick('temporal_beta')">
              <div class="showcase-image">
                  <img src="advert1.jpg" alt="Placeholder for Temporal Anomaly">
              </div>
              <div class="showcase-content">
                  <h3 class="showcase-title">ORDINARY HARDWARE [Warning]</h3>
                  <p class="showcase-description">PENDING RAM BRIDGE TECHNOLOGY.</p>
                  <button class="showcase-button">Probe</button>
              </div>
          </div>
          <div class="showcase-item" onclick="handleShowcaseClick('network_gamma')">
              <div class="showcase-image">
                  <img src="advert2.jpg" alt="Placeholder for Network Link"> </div>
              <div class="showcase-content">
                  <h3 class="showcase-title">3d model generation [Warning]</h3>
                  <p class="showcase-description">Interface with our .ply terrain generators and convert to .glb and others in blender.</p>
                  <button class="showcase-button">Establish Link</button>
              </div>
          </div>
          <div class="showcase-item" onclick="handleShowcaseClick('diagnostic_delta')">
              <div class="showcase-image">
                  <img src="advert3.jpg" alt="Placeholder for Core Diagnostics">
              </div>
              <div class="showcase-content">
                  <h3 class="showcase-title">FREE DIAGNOSTICS [Warning]</h3>
                  <p class="showcase-description">Our company is designed to recycle plastics and other materials and we offer a free diagnostics program.</p>
                  <button class="showcase-button">Analyze Core</button>
              </div>
          </div>
      </div>
  </section>

  <div class="console">
    <input type="text" id="consoleInput" placeholder="> AWAITING DIRECTIVE..." onkeydown="handleConsoleInput(event)" />
  </div>

  <script>
    // --- GIF Floating Animation (Added Jitter) ---
    let gif = document.getElementById("glitchGif");
    let yPosition = 0, yDirection = 1;
    let xPosition = 0; // For horizontal jitter

    function animateGIF() {
      yPosition += 0.4 * yDirection; // Slightly slower vertical float
      if (yPosition > 2 || yPosition < -2) yDirection *= -1;

      // Add horizontal jitter
      xPosition = (Math.random() - 0.5) * 1.5; // Random small horizontal shift

      gif.style.transform = `translate(${xPosition}px, ${yPosition}px)`;
      requestAnimationFrame(animateGIF);
    }
    if (gif) { // Check if GIF element exists
        animateGIF();
    } else {
        console.warn("Glitch GIF element not found.");
    }


    // --- Navigation & Other JS Functions (Keep existing logic) ---
    // Placeholder for navigation functions (as in original code)
    function navigateToGame() { console.log("Navigate: Game"); animateButtonAndNavigate(document.querySelectorAll('.button.play-button')[0], 'game.html'); }
    function navigateToVideoPlayer() { console.log("Navigate: Logs"); animateButtonAndNavigate(document.querySelectorAll('.button.play-button')[1], 'videoPlayer.html'); }
    function navigateToLiquidMusic() { console.log("Navigate: Audio"); animateButtonAndNavigate(document.querySelectorAll('.button.play-button')[2], 'liquidMusic.html'); }
    function navigateToDimension88() { console.log("Navigate: Dim88"); animateButtonAndNavigate(document.querySelectorAll('.button.play-button')[3], 'dimension88.html'); }
    function navigateToAI() { console.log("Navigate: AI Gen"); animateButtonAndNavigate(document.querySelector('.button.ai-button'), 'ai.html'); }
    function navigateToSettings() { console.log("Navigate: Calibration"); animateButtonAndNavigate(document.querySelectorAll('.button.play-button')[4], 'settings.html'); }
    function navigateToForum() { console.log("Navigate: Weapon Lab"); animateButtonAndNavigate(document.querySelectorAll('.button.play-button')[5], 'forum.html'); }
    function navigateToStore() { console.log("Navigate: Acquisitions"); animateButtonAndNavigate(document.querySelectorAll('.button.play-button')[6], 'https://www.ebay.com/usr/ordinarytechnology'); }
    function navigateToAbout() { console.log("Navigate: Info"); animateButtonAndNavigate(document.querySelectorAll('.button.play-button')[7], 'about.html'); }

    // Placeholder for console input handler
    function handleConsoleInput(event) {
        if (event.key === 'Enter') {
            const inputField = event.target;
            const input = inputField.value.trim().toLowerCase();
            inputField.value = ''; // Clear input field

            if (!input) return;

            // Existing easter egg and command logic...
            const commands = {
                'ali3n': 'easteregg.html', 'zombie1': 'egg1.html', 'valve2': 'egg2.html',
                'unr3al': 'egg3.html', 'phant0m': 'egg4.html', 'shadow5': 'egg5.html',
                'glitchx': 'egg6.html', 'oblivion7': 'egg7.html', 'cyb3rpunk': 'egg8.html',
                'n3on9': 'egg9.html', 'matrix10': 'egg10.html', 'quantum11': 'egg11.html',
                'nebula12': 'egg12.html', 'vortex13': 'egg13.html', 'enigma14': 'egg14.html',
                'paradox15': 'egg15.html', 'synapse16': 'egg16.html', 'zenith17': 'egg17.html',
                'help': 'showHelp', 'clear': 'clearConsole', 'nav': 'navigateCommand',
                'shader': 'updateShaderCommand' // Command to trigger shader update
            };
            const parts = input.split(' ');
            const command = parts[0];
            const args = parts.slice(1).join(' ');

            if (commands[command]) {
                const action = commands[command];
                if (action === 'showHelp') {
                    const availableCommands = Object.keys(commands)
                        .filter(k => typeof commands[k] === 'string' && !commands[k].endsWith('.html')) // Filter out egg URLs
                        .map(k => k + (k === 'nav' || k === 'shader' ? ' [args]' : '')) // Add arg hints
                        .join(', ');
                    const eggKeys = Object.keys(commands).filter(k => commands[k].endsWith('.html')).join(', ');
                    showNotification(`Commands: ${availableCommands}. Archives: ${eggKeys}.`);
                } else if (action === 'clearConsole') {
                    showNotification('CONSOLE INPUT CLEARED.'); // No actual output area to clear
                } else if (action === 'navigateCommand') {
                    handleNavCommand(args);
                } else if (action === 'updateShaderCommand') {
                     if (typeof window.updateShader === 'function') {
                        console.log("Attempting to update shader via console...");
                        window.updateShader(args); // Pass the rest of the input as shader code
                        showNotification(`SHADER UPDATE INITIATED.`);
                    } else {
                        showNotification(`SHADER SYSTEM OFFLINE.`);
                    }
                }
                 else if (action.endsWith('.html')) { // Easter Egg URL
                    const eggUrl = 'https://partlydecent.github.io/GAMEHUBORDINARY/' + action;
                    showNotification(`ACCESSING ARCHIVE: ${command.toUpperCase()}...`);
                    setTimeout(() => { window.location.href = eggUrl; }, 500);
                }
            } else {
                showNotification(`DIRECTIVE UNRECOGNIZED: ${command.toUpperCase()}`);
            }
        }
    }

    // Placeholder for showcase item click handler
    function handleShowcaseClick(moduleId) {
      console.log("Interfacing with module:", moduleId);
      showNotification(`MODULE INTERFACE [${moduleId.toUpperCase()}] STATUS: PENDING...`);
      // Add logic for what happens when a card is clicked
    }

    // Helper function for 'nav' command
    function handleNavCommand(target) {
        const destinations = {
            'game': navigateToGame, 'dimension': navigateToGame, // Alias
            'logs': navigateToVideoPlayer, 'videos': navigateToVideoPlayer,
            'audio': navigateToLiquidMusic, 'music': navigateToLiquidMusic,
            'dim88': navigateToDimension88, 'dimension88': navigateToDimension88,
            'ai': navigateToAI, 'generator': navigateToAI,
            'settings': navigateToSettings, 'calibration': navigateToSettings,
            'lab': navigateToForum, 'weaponlab': navigateToForum,
            'store': navigateToStore, 'acquisitions': navigateToStore,
            'about': navigateToAbout, 'info': navigateToAbout,
            'home': () => window.location.reload(), // Reload for 'home'
            'reload': () => window.location.reload()
        };
         if (destinations[target]) {
            showNotification(`NAVIGATING TO: ${target.toUpperCase()}...`);
            setTimeout(() => { destinations[target](); }, 300); // Slight delay
        } else {
            showNotification(`UNKNOWN NAVIGATION TARGET: ${target.toUpperCase()}`);
        }
    }

    // Helper function for displaying temporary notifications
    let notificationTimeout;
    function showNotification(message) {
        clearTimeout(notificationTimeout); // Clear previous timeout if any
        const existingNotification = document.getElementById('consoleNotification');
        if (existingNotification) {
            document.body.removeChild(existingNotification);
        }

        const notification = document.createElement('div');
        notification.id = 'consoleNotification';
        notification.style.position = 'fixed';
        notification.style.bottom = '7rem'; // Position higher above console
        notification.style.left = '50%';
        notification.style.padding = '0.8rem 1.6rem';
        notification.style.background = 'rgba(0, 0, 0, 0.85)';
        notification.style.backdropFilter = 'blur(10px)';
        notification.style.border = '1px solid rgba(var(--rgb-secondary), 0.4)'; // Secondary border
        notification.style.borderRadius = '6px';
        notification.style.color = 'var(--secondary)';
        notification.style.fontFamily = "'Space Grotesk', monospace";
        notification.style.fontSize = '0.9rem';
        notification.style.zIndex = '101';
        notification.style.textAlign = 'center';
        notification.style.textTransform = 'uppercase';
        notification.style.boxShadow = '0 0 20px rgba(var(--rgb-secondary), 0.3)'; // Stronger glow
        notification.style.animation = 'fadeIn 0.3s ease-out forwards, fadeOut 0.4s ease-in 3s forwards'; // Stay 3s
        notification.textContent = message;
        document.body.appendChild(notification);

        // Remove element after fadeOut animation completes
        notificationTimeout = setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3400); // 300ms fadeIn + 3000ms visible + 400ms fadeOut
    }


    // Preload audio
    const warpSound = new Audio('https://partlydecent.github.io/ORDINARY-TECHNOLOGY/warp_sound.mp3');
    warpSound.load();

    // Animate button and navigate function (existing logic)
    function animateButtonAndNavigate(buttonElement, url) {
        if (!buttonElement) {
            console.error("Button element not found for navigation.");
            window.location.href = url; return;
        }
        try {
            const warp = document.createElement('div');
            warp.classList.add('warp-distortion');
            document.body.appendChild(warp);

            warpSound.currentTime = 0;
            warpSound.play().catch(e => console.warn('Audio play failed:', e));

            buttonElement.style.transform = 'scale(0.95)';
            buttonElement.style.opacity = '0.7';

            setTimeout(() => { window.location.href = url; }, 600); // Faster navigation start

            setTimeout(() => {
                if (warp.parentNode) { warp.parentNode.removeChild(warp); }
                 // Reset button style (might not be seen before nav)
                // buttonElement.style.transform = 'scale(1)';
                // buttonElement.style.opacity = '1';
            }, 1200); // Match warp effect duration

        } catch (e) {
            console.error('Navigation animation error:', e);
            window.location.href = url; // Fallback
        }
    }
  </script>

  <script>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

// WebGL Setup
    const webglCanvas = document.getElementById('webglCanvas');
    let gl; // Declare gl globally within this script block
    if (webglCanvas) {
        webglCanvas.width = window.innerWidth;
        webglCanvas.height = window.innerHeight;
        // Try to get webgl2, fall back to webgl1
        gl = webglCanvas.getContext('webgl2') || webglCanvas.getContext('webgl') || webglCanvas.getContext('experimental-webgl');
        if (gl instanceof WebGL2RenderingContext) {
            console.log("WebGL2 Context Initialized.");
        } else if (gl instanceof WebGLRenderingContext || gl instanceof WebGLRenderingContext) { // Handle experimental-webgl too
             console.log("WebGL1 Context Initialized.");
             // IMPORTANT: This shader uses GLSL 300 es features. It WILL likely fail on WebGL1.
             // A production solution would detect the context version and provide a simpler GLSL 100 shader.
        }
    } else {
        console.error("WebGL Canvas element not found!");
    }


    if (!gl) {
        console.log("WebGL not supported, falling back. Background will be static.");
         document.body.style.backgroundColor = '#050511'; // Ensure dark bg
    } else {
        // --- Vertex shader source ---
        // Uses GLSL 3.00 ES - requires WebGL2
        const vertexShaderSource = `#version 300 es
            in vec4 a_position; // 'in' replaces 'attribute'
            void main() {
                gl_Position = a_position;
            }
        `;

        // --- REVISED Fragment shader source - 20 PHASES ---
        // Uses GLSL 3.00 ES - requires WebGL2
        const fragmentShaderSource = `#version 300 es
            precision highp float; // Precision qualifier required in fragment shaders

            // Uniforms: Inputs from JavaScript
            uniform float u_time;
            uniform vec2 u_resolution;

            // Output variable: Replaces gl_FragColor in GLSL 300 es
            out vec4 outColor;

            // --- Constants ---
            const float PI = 3.14159265359;
            const float TWO_PI = 6.28318530718;
            const int FBM_OCTAVES = 5; // Reduced octaves slightly for performance
            const int MAX_RAYMARCH_STEPS = 48; // Reduced raymarch steps
            const float MAX_RAYMARCH_DIST = 12.0;
            const int MANDELBROT_ITER = 40; // Reduced mandelbrot iterations

            // --- Helper Functions ---

            // Pseudo-random number generator
            float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
            float rand(float n){ return fract(sin(n) * 43758.5453123); }

            // Hashing function for noise
            float hash(float n) { return fract(sin(n) * 43758.5453); }

            // Value Noise function
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f); // Smoothstep interpolation
                float n = i.x + i.y * 57.0;
                return mix(mix(hash(n), hash(n + 1.0), f.x),
                           mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);
            }

            // Fractional Brownian Motion (fBm)
            float fbm(vec2 p) {
                float sum = 0.0;
                float amp = 0.7;
                float freq = 1.0;
                for(int i = 0; i < FBM_OCTAVES; i++) {
                    sum += noise(p * freq) * amp;
                    amp *= 0.5;
                    freq *= 2.0; // Standard frequency doubling
                }
                return sum;
            }

            // Simplex noise functions (ported) - Requires GLSL 300 es or higher
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
              const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
              const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
              vec3 i  = floor(v + dot(v, C.yyy) );
              vec3 x0 = v - i + dot(i, C.xxx) ;
              vec3 g = step(x0.yzx, x0.xyz);
              vec3 l = 1.0 - g;
              vec3 i1 = min( g.xyz, l.zxy );
              vec3 i2 = max( g.xyz, l.zxy );
              vec3 x1 = x0 - i1 + C.xxx;
              vec3 x2 = x0 - i2 + C.yyy; // Corrected C.yyy
              vec3 x3 = x0 - D.yyy;
              i = mod289(i);
              vec4 p = permute( permute( permute(
                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                       + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                       + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
              float n_ = 0.142857142857; // 1.0/7.0
              vec3 ns = n_ * D.wyz - D.xzx;
              vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
              vec4 x_ = floor(j * ns.z);
              vec4 y_ = floor(j - 7.0 * x_);
              vec4 x = x_ *ns.x + ns.yyyy;
              vec4 y = y_ *ns.x + ns.yyyy;
              vec4 h = 1.0 - abs(x) - abs(y);
              vec4 b0 = vec4( x.xy, y.xy );
              vec4 b1 = vec4( x.zw, y.zw );
              vec4 s0 = floor(b0)*2.0 + 1.0;
              vec4 s1 = floor(b1)*2.0 + 1.0;
              vec4 sh = -step(h, vec4(0.0));
              vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
              vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
              vec3 p0 = vec3(a0.xy,h.x);
              vec3 p1 = vec3(a0.zw,h.y);
              vec3 p2 = vec3(a1.xy,h.z);
              vec3 p3 = vec3(a1.zw,h.w);
              vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
              p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
              vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
              m = m * m;
              return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
             // 2D Simplex noise convenience function
             float snoise(vec2 v) { return snoise(vec3(v, 0.0)); }

            // Rotation matrix for 2D rotation
            mat2 rotate2D(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }

            // Worley noise (cellular pattern) function
            float worley(vec2 p) {
                float minDist = 10.0; // Initialize with a large distance
                vec2 gridPos = floor(p);
                for (int x = -1; x <= 1; x++) {
                    for (int y = -1; y <= 1; y++) {
                        vec2 neighborCell = gridPos + vec2(float(x), float(y));
                        // Generate a deterministic but pseudo-random point within each cell
                        vec2 pointInCell = vec2(rand(neighborCell), rand(neighborCell + vec2(7.3, 3.7)));
                        // Animate points slightly over time
                        pointInCell = 0.5 + 0.5 * sin(u_time * 0.3 + TWO_PI * pointInCell);
                        vec2 fullPointPos = neighborCell + pointInCell;
                        minDist = min(minDist, length(p - fullPointPos));
                    }
                }
                return minDist;
            }

            // Truchet Pattern Helper function
            float truchetPattern(vec2 uv, float scale) {
                uv *= scale; // Scale the coordinate system
                vec2 ip = floor(uv); // Integer part (cell ID)
                vec2 fp = fract(uv); // Fractional part (position within cell)
                float tileRandVal = rand(ip); // Random value per cell
                float tileType = floor(tileRandVal * 2.0); // Determine tile type (0 or 1)
                float dist; // Distance to the pattern's center line
                if (tileType == 0.0) { // Type 0: Forward slash pattern /
                   dist = abs(fp.x + fp.y - 1.0) / sqrt(2.0); // Distance to line x + y = 1
                } else { // Type 1: Back slash pattern \
                   dist = abs(fp.x - fp.y) / sqrt(2.0); // Distance to line x - y = 0
                }
                // Create a smooth line based on distance from the center (0.5)
                return smoothstep(0.04, 0.06, abs(dist - 0.5));
            }

            // Simple Signed Distance Functions (SDFs) for Raymarching
            float sdSphere(vec3 p, float s) { return length(p) - s; }
            float sdPlane(vec3 p, vec3 n, float h) { return dot(p, n) + h; }

            // --- Color Definitions ---
            vec3 colPrimary = vec3(106.0/255.0, 0.0/255.0, 255.0/255.0); // Purple
            vec3 colSecondary = vec3(0.0/255.0, 255.0/255.0, 204.0/255.0); // Cyan
            vec3 colTertiary = vec3(0.0/255.0, 184.0/255.0, 212.0/255.0); // Teal
            vec3 colGreen = vec3(0.1, 0.8, 0.4); // Brighter Green
            vec3 colGold = vec3(0.9, 0.7, 0.1);
            vec3 colStrangeGreen = vec3(0.1, 0.4, 0.2); // Muted green
            vec3 colDeepRed = vec3(0.6, 0.0, 0.15);
            vec3 colWhite = vec3(1.0);
            vec3 colOrange = vec3(1.0, 0.5, 0.0);
            vec3 colPink = vec3(1.0, 0.4, 0.7);
            vec3 colBackground = vec3(5.0/255.0, 5.0/255.0, 17.0/255.0);

            // Function to get base color for Chromatic Aberration (Simplified Example)
            // This function is basic; a real implementation might vary effect per phase.
            vec3 getColorForCA(vec2 sampleUV, float time) {
                 float noiseVal = fbm(sampleUV * 4.0 + time * 0.15);
                 return mix(colPrimary, colTertiary, noiseVal);
            }


            // --- Main Shader Logic ---
            void main() {
                // Normalized device coordinates, aspect corrected, origin at center
                vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / min(u_resolution.y, u_resolution.x);
                // Original UV coordinates (0 to 1)
                vec2 originalUV = gl_FragCoord.xy / u_resolution.xy;

                // Time for phase calculation, adjust speed factor here
                float time_warp = u_time * 0.1; // Controls overall cycle speed
                const float TOTAL_PHASES_F = 20.0; // Float version for division
                float phase = mod(time_warp, TOTAL_PHASES_F);
                float phaseProgress = fract(phase); // Progress within the current phase (0.0 to 1.0)
                int phaseIndex = int(floor(phase)); // Integer index of the current phase (0 to 19)

                vec3 color = colBackground; // Initialize with background color

                // --- Phase Implementations ---

                // Phase 0: Distorted Grid
                if (phaseIndex == 0) {
                    float warpFactor = 0.1 + 0.05 * sin(u_time * 0.2);
                    warpFactor = max(0.001, warpFactor); // Prevent division by zero
                    // Calculate perspective 'z' based on y, warp factor, and noise
                    float z = 0.1 / max(0.01, 0.1 - uv.y * warpFactor + 0.02 * fbm(uv + u_time * 0.05));
                    z = clamp(z, 0.1, 15.0); // Limit z range
                    vec2 warp = uv * z; // Apply perspective warp
                    // Calculate grid lines
                    vec2 grid = abs(fract(warp * vec2(5.0, 3.0) + u_time * 0.1) - 0.5);
                    float line = smoothstep(0.04, 0.05, min(grid.x, grid.y)) * 0.6; // Grid line intensity
                    float depthFade = fract(z * 0.1 + u_time * 0.15); // Fade based on depth
                    // Base color mixing
                    vec3 baseCol = mix(mix(colPrimary, colTertiary, sin(u_time * 0.1)*0.5+0.5), colSecondary, sin(length(warp)*0.5 - u_time*0.5)*0.5+0.5);
                    color = mix(baseCol * 0.15, baseCol, line * depthFade * 1.5); // Mix background, color, and line intensity
                }

                // Phase 1: Circular Waves
                else if (phaseIndex == 1) {
                    float dist = length(uv); // Distance from center
                    float rings = sin(dist * 18.0 - u_time * 2.5) * 0.5 + 0.5; // Ring pattern
                    rings *= smoothstep(1.8, 0.4, dist); // Fade rings further out
                    float wave = sin(uv.y * 25.0 + u_time * 1.2) * 0.04; // Vertical wave distortion
                    vec2 waved_uv = uv + vec2(wave, sin(uv.x * 15.0 + u_time * 0.8) * 0.03); // Apply wave distortion
                    float n = fbm(waved_uv * 3.5 + u_time * 0.25); // Noise calculation
                    // Mix colors based on rings and noise
                    vec3 baseCol = mix(mix(colSecondary, colTertiary, rings), mix(colGreen, colGold, n), 0.5 + 0.5 * sin(u_time * 0.6 + dist * 2.0));
                    color = mix(baseCol * 0.2, baseCol, rings * 0.8 + n * 0.6); // Final mix
                 }

                // Phase 2: Electric Pulse / Hex Grid
                else if (phaseIndex == 2) {
                    vec2 r = vec2(1.0, 1.732); // Hex grid vectors (sqrt(3))
                    vec2 h = r * 0.5;
                    // Map uv to hex grid coordinates with slight time-based shift
                    vec2 a = mod(uv * 2.0 + u_time * 0.1, r) - h;
                    vec2 b = mod(uv * 2.0 - h + u_time * 0.1, r) - h;
                    vec2 gv = length(a) < length(b) ? a : b; // Closest hex center vector
                    float pulse = sin(u_time * 3.5) * 0.5 + 0.5; // Pulsing factor
                    float electric = sin(length(gv) * 25.0 - u_time * 3.5); // Electric line calculation
                    electric = smoothstep(-0.1, 0.15, electric) - smoothstep(0.15, 0.4, electric); // Sharpen lines
                    float distortion = fbm(uv * 2.5 + vec2(u_time * 0.15, 0.0)); // Noise distortion
                    vec3 baseColor = mix(colTertiary, colGreen, distortion); // Base color mix
                    vec3 glowColor = mix(colSecondary, colPrimary, pulse); // Glow color mix
                    color = mix(baseColor * 0.1, glowColor, electric * pulse * 1.5); // Mix base, glow, and electric lines
                    // Add finer detail based on x/y sine waves
                    float detail = abs(sin(uv.x * 22.0 + u_time * 1.1)) * abs(sin(uv.y * 22.0 - u_time * 1.3));
                    color += glowColor * detail * 0.08;
                }

                // Phase 3: Vortex / Spiral
                else if (phaseIndex == 3) {
                    float angle = atan(uv.y, uv.x); // Angle from center
                    float radius = length(uv); // Distance from center
                    angle += 0.1 * fbm(uv * 0.5 + u_time * 0.05); // Distort angle with noise
                    float spiral_angle = angle * 6.0 + radius * 8.0 - u_time * 2.2; // Spiral calculation
                    float spiral = smoothstep(-0.2, 0.2, sin(spiral_angle)); // Sharpen spiral lines
                    float radius_distorted = radius + sin(angle * 10.0 + u_time * 0.3) * 0.08; // Distort radius
                    float bands = fract(radius_distorted * 6.0 - u_time * 0.6); // Radial bands
                    bands = smoothstep(0.0, 0.1, bands) * smoothstep(0.8, 0.5, bands); // Shape bands
                    float turb = fbm(vec2(radius_distorted * 6.0, angle * 3.0) + u_time * 0.15); // Turbulence noise
                    // Color mixing based on radius and angle
                    vec3 deepColor = mix(colPrimary, colDeepRed, sin(radius_distorted * 12.0)*0.5+0.5);
                    vec3 brightColor = mix(colGold, colSecondary, cos(angle * 4.0)*0.5+0.5);
                    color = mix(deepColor * 0.5, brightColor, bands + turb * 0.4); // Mix base, bands, turbulence
                    color += brightColor * spiral * 0.3; // Add spiral color
                }

                // Phase 4: Organic / Cellular (Value Noise based)
                else if (phaseIndex == 4) {
                    vec2 cellUV = uv * mix(3.0, 5.0, phaseProgress); // Zoom effect
                    float n = fbm(cellUV + u_time * 0.2); // Base noise
                    float cells = 0.0;
                    // Simple Voronoi-like pattern
                    for (float x = -1.0; x <= 1.0; x += 1.0) {
                         for (float y = -1.0; y <= 1.0; y += 1.0) {
                             vec2 neighbor = vec2(x, y);
                             vec2 cellCenter = floor(cellUV) + neighbor;
                             vec2 point = cellCenter + 0.5 + sin(u_time*0.1+cellCenter)*0.3; // Jittery cell centers
                             cells += smoothstep(0.4, 0.38, length(cellUV - point)); // Additive smooth bumps
                         }
                    }
                    cells = clamp(cells, 0.0, 1.0); // Clamp result
                    vec3 cellColor = mix(colStrangeGreen, colPrimary, n); // Mix base colors with noise
                    cellColor = mix(cellColor, colDeepRed, smoothstep(0.6, 0.8, n)); // Add highlights
                    color = mix(colBackground * 0.5, cellColor, cells * 1.2); // Mix with background
                    color += fbm(uv * 15.0 + u_time * 0.5) * 0.05; // Add fine grain noise
                }

                // Phase 5: Glitch / Corruption
                else if (phaseIndex == 5) {
                    float t = phaseProgress; // Use progress for intensity
                    // Blocky glitch effect
                    vec2 blockUV = floor(originalUV * mix(20.0, 60.0, sin(u_time * 2.0)*0.5+0.5)) / mix(20.0, 60.0, sin(u_time * 2.0)*0.5+0.5);
                    float blockNoise = fbm(blockUV * 5.0 + u_time * 0.5);
                    color = mix(colPrimary, colSecondary, blockNoise);
                    // Screen tearing effect
                    float tearLine = sin(originalUV.y * 10.0 + u_time * 5.0) * 0.5 + 0.5;
                    float tearAmount = smoothstep(0.8, 0.85, tearLine); // Sharp tear line
                    float offset = tearAmount * (rand(vec2(floor(u_time*2.0), floor(originalUV.y*10.0))) - 0.5) * 0.1; // Random offset
                    vec2 tearUV = uv + vec2(offset * t, 0.0); // Apply offset
                    float tearNoise = fbm(tearUV * 4.0 + u_time * 0.3); // Recalculate noise with offset UV
                    color = mix(color, mix(colTertiary, colDeepRed, tearNoise), tearAmount); // Blend based on tear
                    // Chromatic Aberration (simplified)
                    float ca_offset = (0.005 + 0.01 * abs(sin(u_time * 3.0))) * t; // Varying offset
                    vec3 colR = getColorForCA(uv + vec2(ca_offset, 0.0), u_time);
                    vec3 colB = getColorForCA(uv - vec2(ca_offset * 0.5, ca_offset * 0.8), u_time);
                    color = vec3(colR.r, color.g, colB.b); // Combine R, G(original), B channels
                    // Noise overlay
                    color += (rand(originalUV + fract(u_time * 10.0)) - 0.5) * 0.15 * t;
                }

                // Phase 6: Simplex Noise Flow
                else if (phaseIndex == 6) {
                    vec2 p = uv * 2.0; // Zoom in
                    float intensity = fbm(p + u_time * 0.3); // Base flow pattern
                    // Create ridges using Simplex noise
                    float ridges = abs(snoise(vec3(p * 1.5, u_time * 0.5)));
                    ridges = pow(1.0 - ridges, 4.0); // Sharpen ridges
                    vec3 flowColor = mix(colPrimary, colTertiary, smoothstep(0.0, 1.0, intensity)); // Map noise to color
                    color = mix(colBackground * 0.4, flowColor, ridges * 1.5); // Mix background, color, ridges
                    color *= 1.0 - smoothstep(0.8, 1.5, length(uv)); // Fade edges using vignette
                }

                // Phase 7: Worley Noise (Cellular v2)
                else if (phaseIndex == 7) {
                     vec2 p = uv * 3.0 + vec2(u_time * 0.1, u_time * 0.2); // Pan slowly
                     float d = worley(p); // Calculate distance to nearest point
                     float edges = 1.0 - smoothstep(0.0, 0.05, d); // Create sharp edges
                     float cells = smoothstep(0.0, 0.4, d); // Fill cells based on distance
                     vec3 cellCol = mix(colStrangeGreen, colGold, cells * 1.2); // Color cells
                     color = mix(cellCol * 0.3, colWhite, edges); // Mix cell color with white edges
                }

                // Phase 8: Rotating Tunnel
                else if (phaseIndex == 8) {
                    vec2 p = uv;
                    p = rotate2D(u_time * 0.4) * p; // Rotate coordinates
                    float angle = atan(p.y, p.x); // Angle from center
                    float radius = length(p); // Distance from center
                    // Noise based on inverse radius and angle to create tunnel effect
                    float tunnel = fbm(vec2(1.0 / (radius + 0.1), angle * 2.0) + u_time * 0.2);
                    float rings = sin(radius * 20.0 - u_time * 3.0) * 0.5 + 0.5; // Radial rings
                    vec3 tunnelCol = mix(colSecondary, colPink, smoothstep(0.0, 1.0, tunnel)); // Color based on tunnel noise
                    color = mix(colBackground, tunnelCol, (smoothstep(0.0, 0.8, tunnel) + rings * 0.5) * 0.8); // Mix tunnel, rings, background
                }

                 // Phase 9: Truchet Tiles
                else if (phaseIndex == 9) {
                    float scale = mix(4.0, 8.0, sin(u_time * 0.5) * 0.5 + 0.5); // Pulsing scale
                    float pattern = truchetPattern(uv, scale); // Get pattern lines
                    vec2 uvShift = uv * scale;
                    float baseNoise = noise(floor(uvShift) + u_time * 0.1); // Noise per tile
                    vec3 tileColor = mix(colPrimary, colTertiary, baseNoise); // Color per tile
                    color = mix(tileColor * 0.2, colWhite * 0.9, pattern); // Mix tile color with pattern lines
                }

                // Phase 10: Pseudo Plasma
                else if (phaseIndex == 10) {
                    // Combine multiple sine waves based on coordinates and time
                    float v = 0.0;
                    v += sin((uv.x * 3.0 + u_time * 0.8));
                    v += sin((uv.y * 4.0 - u_time * 0.5) + v * 0.5); // Feedback
                    v += sin((uv.x * uv.y * 2.0 + u_time));
                    // Add radial component
                    float cx = uv.x + 0.5 * sin(u_time / 5.0);
                    float cy = uv.y + 0.5 * cos(u_time / 3.0);
                    v += sin(sqrt(cx*cx + cy*cy) * 5.0 + u_time);
                    v *= 0.5; // Normalize roughly
                    // Mix colors based on plasma value
                    vec3 plasmaCol1 = mix(colDeepRed, colOrange, sin(u_time*0.2)*0.5+0.5);
                    vec3 plasmaCol2 = mix(colPrimary, colSecondary, cos(u_time*0.3)*0.5+0.5);
                    color = mix(plasmaCol1, plasmaCol2, smoothstep(-0.8, 0.8, v));
                }

                // Phase 11: Digital Rain (Matrix style)
                else if (phaseIndex == 11) {
                    vec2 gridUV = originalUV * vec2(80.0, 60.0); // Character grid resolution
                    vec2 cell = floor(gridUV); // Cell coordinates
                    // Random speed and start position per column
                    float speed = rand(cell.x) * 3.0 + 1.0;
                    float streamStart = rand(cell.x) * 10.0;
                    float streamPos = fract(streamStart - u_time * speed * 0.1); // Current head position (0-1)
                    float charY = originalUV.y; // Use normalized Y
                    // Calculate intensity: bright head, fading tail
                    float tailLength = 0.15 + rand(cell.x)*0.1;
                    float charIntensity = smoothstep(streamPos, streamPos + 0.01, charY) // Turn on at head
                                          * (1.0 - smoothstep(streamPos + 0.01, streamPos + tailLength, charY)); // Fade out tail
                    float charValue = rand(cell + floor((streamStart - u_time * speed * 0.1)*10.0)); // Random character change based on time/speed
                    vec3 rainCol = mix(colStrangeGreen * 0.5, colGreen * 1.5, step(0.5, charValue)); // Dim/Bright green
                    color = mix(colBackground, rainCol, charIntensity); // Mix background, character color, intensity
                }

                // Phase 12: Mandelbrot Zoom (simple, low iteration)
                else if (phaseIndex == 12) {
                    float zoom = 0.5 + pow(mod(u_time * 0.05, 5.0) + 1.0, 2.0); // Slow zoom cycle (5 seconds)
                    vec2 c = uv * 1.5 / zoom - vec2(0.7, 0.0); // Center on interesting area, adjust scale
                    vec2 z = vec2(0.0);
                    int iter = 0;
                    for(int i = 0; i < MANDELBROT_ITER; i++) {
                        // Z = Z^2 + C
                        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                        if(dot(z,z) > 4.0) break; // Escape condition
                        iter++;
                    }
                    float m = float(iter) / float(MANDELBROT_ITER); // Normalized iteration count
                    m = pow(m, 0.5); // Adjust contrast
                    // Color based on iteration count
                    color = mix(colBackground, mix(colPrimary, colGold, m), smoothstep(0.0, 0.1, m)); // Only color escaped points slightly
                    if (iter == MANDELBROT_ITER) color = colBackground * 0.5; // Color inside set dark
                }

                // Phase 13: Wobbly Grid Distortion (Simplex based)
                else if (phaseIndex == 13) {
                    // Calculate distortion using Simplex noise
                    vec2 distortion = vec2(
                        snoise(vec3(uv * 2.0, u_time * 0.3)),
                        snoise(vec3(uv * 2.0 + 10.0, u_time * 0.35))
                    ) * 0.15; // Amount of distortion
                    vec2 distortedUV = uv + distortion; // Apply distortion
                    vec2 grid = abs(fract(distortedUV * 6.0) - 0.5); // Calculate grid lines on distorted UVs
                    float line = smoothstep(0.03, 0.04, min(grid.x, grid.y)); // Grid line intensity
                    float noiseVal = fbm(distortedUV * 3.0 + u_time * 0.1); // Noise value for color
                    vec3 gridCol = mix(colTertiary, colPink, noiseVal); // Grid color
                    color = mix(colBackground * 0.5, gridCol, line * 1.2); // Mix background, color, lines
                }

                // Phase 14: Heightmap Flow (Simplex Noise Based - Simplified Lighting)
                else if (phaseIndex == 14) {
                     float h = snoise(vec3(uv * 1.5, u_time * 0.2)); // Base heightmap noise
                     float flow = snoise(vec3(uv * 3.0 + h * 0.3, u_time * 0.4)); // Flow pattern noise, influenced by height
                     // Simplified lighting based on height 'h' and a light direction pseudo-angle
                     float lightAngle = 0.785; // ~45 degrees
                     float light = 0.5 + h * 0.5 * cos(atan(uv.y, uv.x) - lightAngle); // Basic directional light illusion
                     light = clamp(light, 0.2, 1.0); // Clamp light value
                     // Color terrain and water areas
                     vec3 terrainColor = mix(colGreen * 0.8, colGold * 0.6, h * 0.5 + 0.5);
                     vec3 waterColor = mix(colPrimary * 0.7, colTertiary * 0.9, flow * 0.5 + 0.5);
                     // Mix based on height, apply light to terrain
                     color = mix(waterColor, terrainColor * light, smoothstep(-0.1, 0.1, h)) * 0.8;
                }

                // Phase 15: Recursive Boxes Fractal
                else if (phaseIndex == 15) {
                    vec2 p = abs(uv) * 0.8; // Use absolute value for symmetry, scale down slightly
                    float scale = 1.5 + 0.5 * sin(u_time * 0.4); // Pulsing scale factor
                    // Iterate folding/scaling
                    for(int i = 0; i < 4; i++) {
                        p = abs(p * scale - 1.0); // Fold and scale
                        // Optional: Add rotation per iteration
                        // p = rotate2D(0.1 * float(i) + u_time*0.1) * p;
                        if (dot(p,p) > 20.0) break; // Bail out if values get too large
                    }
                    float result = length(p) * 0.2; // Final value based on length
                    result = sin(result * 10.0 + u_time); // Apply sine wave for color mapping
                    color = mix(colSecondary, colPrimary, smoothstep(-0.5, 0.5, result)); // Mix colors based on result
                }

                // Phase 16: Crystal Growth (Worley derivative)
                else if (phaseIndex == 16) {
                     vec2 p = uv * 2.5; // Scale coordinates
                     float d1 = worley(p); // First layer of Worley noise
                     float d2 = worley(p + vec2(5.2, 1.3)); // Second layer, offset
                     // Combine layers to create crystal-like structures
                     float crystals = pow(1.0 - smoothstep(0.0, 0.1, d1), 2.0); // Core crystals
                     crystals += pow(1.0 - smoothstep(0.0, 0.05, d2), 2.0) * 0.5; // Smaller secondary crystals
                     crystals = clamp(crystals, 0.0, 1.0);
                     float grain = fbm(p * 10.0 + u_time * 0.1); // Noise for texture/color variation
                     vec3 crystalCol = mix(colWhite * 0.8, colTertiary, grain); // Base crystal color
                     color = mix(colBackground * 0.8, crystalCol, crystals); // Mix background and crystals
                }

                // Phase 17: Flickering Scanlines / Bad Signal
                else if (phaseIndex == 17) {
                     // Intensity noise bands varying vertically and over time
                     float intensity = 0.5 + 0.5 * noise(vec2(u_time * 1.5, originalUV.y * 5.0));
                     // Horizontal flicker segments based on time and y position
                     float flickerSeed = floor(u_time * 15.0) + floor(originalUV.y * 10.0);
                     float flicker = rand(flickerSeed);
                     intensity *= smoothstep(0.2, 0.8, flicker); // Apply flicker to intensity
                     // Base underlying noisy color
                     vec3 baseCol = mix(colPrimary, colSecondary, noise(uv*3.0 + u_time*0.2));
                     // Create scanline effect
                     float scanlineY = fract(originalUV.y * u_resolution.y * 0.5); // Scanline position
                     float scanlineEffect = smoothstep(0.4, 0.5, scanlineY) * (1.0 - smoothstep(0.5, 0.6, scanlineY));
                     // Mix base color with dark scanlines, modulated by noisy intensity
                     color = mix(baseCol * 0.5, vec3(0.0), scanlineEffect * intensity * 1.5);
                     // Add overall noise, also modulated by intensity
                     color += (rand(originalUV + u_time) - 0.5) * 0.1 * intensity;
                }

                // Phase 18: Simple Raymarched Scene (Sphere/Plane)
                else if (phaseIndex == 18) {
                    vec3 ro = vec3(0.0, 0.0, -3.0 + sin(u_time * 0.3)); // Ray origin (camera moves slightly)
                    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction based on screen coordinates
                    vec3 col = colBackground; // Default color is background
                    float t = 0.0; // Distance traveled along ray

                    for(int i = 0; i < MAX_RAYMARCH_STEPS; i++) {
                        vec3 p = ro + rd * t; // Current point along ray
                        // Define scene using SDFs
                        vec3 sphereCenter = vec3(0.0, sin(u_time * 0.8)*0.5 - 0.2, 0.0); // Oscillating sphere
                        float dSphere = sdSphere(p - sphereCenter, 0.5); // Distance to sphere
                        float dPlane = sdPlane(p, vec3(0.0, 1.0, 0.0), 1.0); // Distance to ground plane
                        float d = min(dSphere, dPlane); // Distance to nearest surface

                        if(d < 0.001 * t) { // Hit condition (tolerance increases with distance)
                            vec3 hitCol; // Color of the hit surface
                            vec3 normal; // Normal of the hit surface
                            // Determine which object was hit and set color/normal
                            if (dPlane < dSphere) {
                                hitCol = colGreen * 0.8;
                                normal = vec3(0.0, 1.0, 0.0); // Plane normal
                            } else {
                                hitCol = colPrimary;
                                // Estimate normal for sphere using SDF gradient
                                vec2 eps = vec2(0.001, 0.0);
                                normal = normalize(vec3(
                                    sdSphere(p + eps.xyy - sphereCenter, 0.5) - sdSphere(p - eps.xyy - sphereCenter, 0.5),
                                    sdSphere(p + eps.yxy - sphereCenter, 0.5) - sdSphere(p - eps.yxy - sphereCenter, 0.5),
                                    sdSphere(p + eps.yyx - sphereCenter, 0.5) - sdSphere(p - eps.yyx - sphereCenter, 0.5)
                                ));
                            }
                            // Simple directional lighting + ambient
                            float light = max(0.2, dot(normal, normalize(vec3(-0.7, 0.7, -0.5))));
                            col = hitCol * light;
                            break; // Exit loop on hit
                        }
                        t += d; // March forward by the distance to the nearest surface
                        if(t > MAX_RAYMARCH_DIST) break; // Stop if ray goes too far
                    }
                    color = col; // Assign final color
                 }

                // Phase 19: Warp Speed Streaks
                else { // phaseIndex == 19
                    float radius = length(uv); // Distance from center
                    float streaks = 0.0; // Accumulator for streak intensity
                    // Loop to create multiple stars/streaks
                    for(float i = 0.0; i < 15.0; i++) {
                        float starSeed = i * 13.37; // Unique seed per star
                        // Calculate star's outward motion and angle over time
                        float starTime = u_time * (0.5 + rand(starSeed)) * 1.5 + rand(starSeed + 1.0) * 10.0;
                        float starDist = fract(starTime) * 3.0; // Star moves 0 to 3 units out
                        float starAngle = rand(starSeed + 2.0) * TWO_PI + u_time * rand(starSeed + 3.0) * 0.05; // Random base angle + slow rotation
                        vec2 starPos = vec2(cos(starAngle), sin(starAngle)) * starDist; // Star position
                        // Calculate distance from current pixel to star
                        float distToStar = length(uv - starPos);
                        // Calculate streak length based on distance from center
                        float streakLength = 0.02 + starDist * 0.1; // Streaks longer further out
                        // Calculate intensity of the streak based on distance and fade out
                        float streakIntensity = smoothstep(streakLength, 0.0, distToStar) // Create streak shape
                                                * (1.0 - smoothstep(1.0, 1.5, starDist)); // Fade stars near edge
                        streaks += streakIntensity; // Add to total intensity
                    }
                    // Color streaks based on radius
                    vec3 streakCol = mix(colWhite, colSecondary, clamp(radius*0.5, 0.0, 1.0));
                    color = mix(colBackground, streakCol, clamp(streaks, 0.0, 1.0)); // Mix background and streaks
                }


                // --- Apply Global Effects ---

                // Subtle Scanlines
                float scanlineVal = sin(originalUV.y * u_resolution.y * 0.8 + u_time * 0.1) * 0.5 + 0.5;
                float scanlineIntensity = 0.03 + 0.015 * sin(u_time * 0.5); // Slower intensity change
                // Apply scanlines by slightly darkening/brightening based on scanlineVal
                color = mix(color, color * (1.0 - scanlineIntensity * 0.8), smoothstep(0.3, 0.0, scanlineVal));
                color = mix(color, color * (1.0 + scanlineIntensity * 0.5), smoothstep(0.7, 1.0, scanlineVal));

                // Vignette effect to darken edges
                float vignette = smoothstep(1.5, 0.5, length(uv)); // Control vignette size/falloff
                color *= vignette;

                // Final Output - Ensure color values are within valid range [0, 1]
                outColor = vec4(clamp(color, 0.0, 1.0), 1.0);
            }
        `;

        // --- WebGL utility functions (createShader, createProgram) ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const shaderType = type === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment';
                console.error(`>>> Shader compile error (${shaderType}):\n${gl.getShaderInfoLog(shader)}`);
                const lines = source.split('\n');
                const sourceWithLines = lines.map((line, index) => `${index + 1}: ${line}`).join('\n');
                console.error(`--- Shader Source (${shaderType}) ---\n${sourceWithLines}\n--------------------------`);
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            if (!vertexShader || !fragmentShader) {
                 console.error("Cannot create program without valid shaders.");
                 return null;
            }
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('>>> Program link error:', gl.getProgramInfoLog(program));
                // Log info about attached shaders
                 const shaders = gl.getAttachedShaders(program);
                 shaders.forEach(shader => {
                     console.error(`--- Attached ${gl.getShaderParameter(shader, gl.SHADER_TYPE) === gl.VERTEX_SHADER ? 'Vertex' : 'Fragment'} Shader Info Log ---\n${gl.getShaderInfoLog(shader)}`);
                 });

                gl.deleteProgram(program);
                return null;
            }
            // It's good practice to detach shaders after successful linking, though not strictly required
            // gl.detachShader(program, vertexShader);
            // gl.detachShader(program, fragmentShader);
            return program;
        }

        // --- Initialize WebGL shaders and program ---
        let program;
        let positionAttributeLocation = -1; // Initialize with -1 (invalid location)
        let timeUniformLocation = null;
        let resolutionUniformLocation = null;
        let positionBuffer = null;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource); // Modifiable if using updateShader
        program = createProgram(gl, vertexShader, fragmentShader);

        // Delete shaders after linking program - they are no longer needed
        if (vertexShader) gl.deleteShader(vertexShader);
        if (fragmentShader) gl.deleteShader(fragmentShader); // Delete the initial one


        if (program) {
            // Get attribute and uniform locations *after* linking the program
            positionAttributeLocation = gl.getAttribLocation(program, "a_position");
            timeUniformLocation = gl.getUniformLocation(program, "u_time");
            resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");

            // Check if locations are valid
            if (positionAttributeLocation === -1) console.warn("Attribute 'a_position' not found in shader program.");
            if (timeUniformLocation === null) console.warn("Uniform 'u_time' not found in shader program.");
            if (resolutionUniformLocation === null) console.warn("Uniform 'u_resolution' not found in shader program.");


            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, 1, -1, -1, 1, 1, 1, -1]; // Fullscreen quad using TRIANGLE_STRIP
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            let startTime = performance.now();
            let animationFrameId = null; // To potentially cancel the frame request

            function render(now) {
                if (!program) { // Stop if program became invalid (e.g., during update)
                    if(animationFrameId) cancelAnimationFrame(animationFrameId);
                    return;
                }

                let time = (now - startTime) * 0.001;

                // Resize canvas check (more efficient than resize event listener for continuous resizing)
                if (webglCanvas.width !== window.innerWidth || webglCanvas.height !== window.innerHeight) {
                    webglCanvas.width = window.innerWidth;
                    webglCanvas.height = window.innerHeight;
                    // Update the WebGL viewport to match the canvas size
                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                }

                // Select the program to use
                gl.useProgram(program);

                // Set up vertex attribute pointer
                if (positionAttributeLocation !== -1 && positionBuffer !== null) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer); // Ensure correct buffer is bound
                    gl.enableVertexAttribArray(positionAttributeLocation);
                    gl.vertexAttribPointer(
                        positionAttributeLocation, // location
                        2, // size (num components per iteration)
                        gl.FLOAT, // type
                        false, // normalize
                        0, // stride (bytes to next element)
                        0 // offset (bytes from start)
                    );
                }

                // Set uniforms
                if (timeUniformLocation !== null) {
                   gl.uniform1f(timeUniformLocation, time);
                }
                if (resolutionUniformLocation !== null) {
                   gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
                }

                // Draw the quad
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); // Draw 4 vertices as a triangle strip

                // Request the next frame
                animationFrameId = requestAnimationFrame(render);
            }
            // Start the rendering loop
            animationFrameId = requestAnimationFrame(render);

        } else {
            console.error(">>> Failed to initialize WebGL program. Background will be static.");
            document.body.style.backgroundColor = '#050511';
        }

        // --- Function to update shader dynamically ---
        window.updateShader = function(newShaderCode) {
            if (!gl) {
                if(typeof showNotification === 'function') showNotification("WebGL inactive. Cannot update shader.");
                else console.warn("WebGL inactive. Cannot update shader.");
                return;
            }
            console.log("Attempting shader update...");
            try {
                // Basic validation
                if (!newShaderCode || newShaderCode.indexOf('main()') === -1) {
                     if(typeof showNotification === 'function') showNotification("Invalid shader code: Missing main() function.");
                     else console.error("Invalid shader code provided: Missing main() function.");
                    console.error("Provided code:\n", newShaderCode);
                    return;
                }

                // Construct the full source for the new fragment shader
                 const completeNewFragmentSource = `#version 300 es
                    precision highp float;
                    uniform float u_time;
                    uniform vec2 u_resolution;
                    out vec4 outColor;

                    // --- Include Common Helper Functions ---
                    float hash(float n) { return fract(sin(n) * 43758.5453); }
                    float noise(vec2 p) { vec2 i=floor(p),f=fract(p);f=f*f*(3.0-2.0*f);float n=i.x+i.y*57.;return mix(mix(hash(n),hash(n+1.),f.x),mix(hash(n+57.),hash(n+58.),f.x),f.y); }
                    float fbm(vec2 p) { float s=0.,a=.7,f=1.;for(int i=0;i<${FBM_OCTAVES};i++){s+=noise(p*f)*a;a*=.5;f*=2.;}return s;}
                    float rand(vec2 co){ return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453); }
                    // --- END Helper Functions ---

                    // --- Common Colors ---
                    vec3 colPrimary = vec3(106./255., 0., 1.);
                    vec3 colSecondary = vec3(0., 1., 204./255.);
                    vec3 colTertiary = vec3(0., 184./255., 212./255.);
                    vec3 colBackground = vec3(5.0/255.0, 5.0/255.0, 17.0/255.0);
                    // --- END Colors ---

                    ${newShaderCode} // Inject the user's main() and other functions here
                `;

                 // Create new vertex and fragment shaders
                 // Using the *same* vertex shader source for simplicity
                 const currentVertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
                 const newFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, completeNewFragmentSource);

                 if (!newFragmentShader || !currentVertexShader) {
                     console.error("Failed to compile new shaders during update.");
                     // Clean up any successfully compiled shader
                     if (newFragmentShader) gl.deleteShader(newFragmentShader);
                     if (currentVertexShader) gl.deleteShader(currentVertexShader);
                      if(typeof showNotification === 'function') showNotification("SHADER COMPILE ERROR. Check console.");
                      else console.error("SHADER COMPILE ERROR.");
                     return;
                 }

                 // Create and link the new program
                 const newProgram = createProgram(gl, currentVertexShader, newFragmentShader);

                 // Delete the individual shaders now that they are linked (or failed to link)
                 gl.deleteShader(newFragmentShader);
                 gl.deleteShader(currentVertexShader);


                 if (!newProgram) {
                     console.error("Failed to link new program during update.");
                      if(typeof showNotification === 'function') showNotification("SHADER LINK ERROR. Check console.");
                      else console.error("SHADER LINK ERROR.");
                     // Keep the old program active
                     return;
                 }

                 // --- Success! Switch to the new program ---

                 // Delete the old program *before* assigning the new one
                 if (program) {
                     gl.deleteProgram(program);
                 }
                 program = newProgram; // Assign the new program

                 // Re-get all attribute and uniform locations for the *new* program
                 positionAttributeLocation = gl.getAttribLocation(program, "a_position");
                 timeUniformLocation = gl.getUniformLocation(program, "u_time");
                 resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");

                 // Check new locations (optional, for debugging)
                 if (positionAttributeLocation === -1) console.warn("New program missing 'a_position' attribute.");
                 if (timeUniformLocation === null) console.warn("New program missing 'u_time' uniform.");
                 if (resolutionUniformLocation === null) console.warn("New program missing 'u_resolution' uniform.");

                 // No need to rebind buffer if it hasn't changed, but ensure it's bound for the first render with new program setup
                 gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

                 console.log("Shader updated successfully.");
                  if(typeof showNotification === 'function') showNotification("SHADER UPDATE SUCCESSFUL.");
                  else console.log("SHADER UPDATE SUCCESSFUL.");

             } catch (e) {
                 console.error('>>> Shader update error:', e);
                  if(typeof showNotification === 'function') showNotification(`SHADER UPDATE FAILED: ${e.message}`);
                  else console.error(`SHADER UPDATE FAILED: ${e.message}`);
             }
         };

        // Window resize listener (updates canvas size, viewport updated in render loop)
        window.addEventListener('resize', () => {
            if (webglCanvas) {
                 webglCanvas.width = window.innerWidth;
                 webglCanvas.height = window.innerHeight;
                 // Viewport update is handled within the render loop now.
            }
        });

    } // End of WebGL context check











// Advanced Particle System (Leveraging Web Animations API)
function createParticles() {
    const container = document.getElementById('particles');
    if (!container) {
        console.error("Particle container not found!");
        return;
    }
    container.innerHTML = ''; // Clear existing particles for refresh

    // --- Configuration ---
    const baseParticleCount = 100; // Base count, adjust as needed
    const highPerfMultiplier = 1.5; // Increase density slightly on larger screens
    const lowPerfMultiplier = 0.7; // Reduce density on smaller screens

    // Detect basic performance level (can be refined)
    const isHighPerformance = window.innerWidth > 1024 && !navigator.userAgent.includes("Mobi");
    const isLowPerformance = window.innerWidth < 768 || navigator.userAgent.includes("Mobi");

    let particleCount = baseParticleCount;
    if (isHighPerformance) {
        particleCount = Math.floor(baseParticleCount * highPerfMultiplier);
    } else if (isLowPerformance) {
        particleCount = Math.floor(baseParticleCount * lowPerfMultiplier);
    }

    const themeColors = [
        'var(--primary)',   // From your CSS variables
        'var(--secondary)',
        'var(--tertiary)',
        'rgba(var(--rgb-primary), 0.6)',
        'rgba(var(--rgb-secondary), 0.7)',
        'rgba(var(--rgb-tertiary), 0.5)',
        '#FFFFFF'
    ];

    // --- Particle Creation Loop ---
    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.classList.add('particle');

        // --- Visual Properties ---
        const isSparkle = Math.random() > 0.9; // Rare bright sparkles
        const sizeMultiplier = isSparkle ? 1.5 : (Math.random() > 0.9 ? 2.5 : 1); // Occasional larger particles
        const size = (Math.random() * 2.5 + 0.5) * sizeMultiplier; // Size range 0.5px to ~9px

        const startX = Math.random() * 110 - 5; // Start position X (-5% to 105%)
        const startYOffset = size + Math.random() * 20; // Start slightly below screen

        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.left = `${startX}%`;
        particle.style.bottom = `-${startYOffset}px`; // Start below viewport

        // Color Selection: Mix theme colors with some random HSL for variety
        let color;
        if (Math.random() > 0.4) {
            color = themeColors[Math.floor(Math.random() * themeColors.length)];
        } else {
            // Random HSL: Focus on bright, saturated colors
            const hue = Math.random() * 360;
            const saturation = 70 + Math.random() * 30; // 70-100%
            const lightness = 55 + Math.random() * 15; // 55-70%
            color = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        // Use background for solid colors, potentially background-image for gradients if needed
        particle.style.background = color;

        // Opacity: Generally lower, sparkles brighter initially
        const baseOpacity = isSparkle ? 0.9 : Math.random() * 0.4 + 0.1; // 0.1 to 0.5 base, sparkles start brighter
        particle.style.opacity = baseOpacity; // Initial opacity (will be animated)

        // Filters & Blend Modes for visual variety (use sparingly for performance)
        if (Math.random() > 0.6) {
            const filterType = Math.random();
            if (filterType > 0.6) {
                particle.style.filter = `blur(${Math.random() * 1.5}px)`; // More blur variation
            } else if (filterType > 0.3) {
                // particle.style.filter = `saturate(${1 + Math.random() * 1})`; // Subtle saturation boost
            }
            // Add hue-rotate for more color shifting? Use carefully.
            // else { particle.style.filter = `hue-rotate(${Math.random() * 60 - 30}deg)`; }
        }
        if (Math.random() > 0.85 && !isLowPerformance) { // Less frequent blend modes on lower perf
            particle.style.mixBlendMode = Math.random() > 0.5 ? 'screen' : 'overlay'; // Or 'lighten', 'color-dodge'
        }

        container.appendChild(particle);

        // --- Animation using Web Animations API ---
        const duration = (Math.random() * 18 + 12) * 1000; // 12s to 30s duration (in ms)
        const delay = Math.random() * 15 * 1000; // Up to 15s delay (in ms)

        // Movement Calculation
        const endY = -(window.innerHeight + startYOffset + 50); // Ensure it goes well off-screen top
        const horizontalMovement = (Math.random() - 0.5) * (window.innerWidth * 0.3); // Max 30% horizontal drift
        const endX = `calc(${startX}% + ${horizontalMovement}px)`;

        // Define Keyframes programmatically
        const keyframes = [
            // Start state (matches initial style)
            { transform: `translate(0, 0) rotate(0deg) scale(1)`, opacity: baseOpacity },
            // Mid-point(s) for non-linear movement (optional)
            { transform: `translate(${(Math.random()-0.5)*40}px, ${endY * 0.4}px) rotate(${(Math.random()-0.5)*90}deg) scale(${1 + Math.random()*0.3})`, opacity: Math.min(1, baseOpacity * 1.5) , offset: 0.3 + Math.random() * 0.4 }, // Add some wobble/rotation/scaling mid-flight
            // End state
            { transform: `translate(${horizontalMovement}px, ${endY}px) rotate(${(Math.random()-0.5)*360}deg) scale(${Math.random() * 0.5 + 0.2})`, opacity: 0 }
        ];

        // Define Animation Options
        const options = {
            duration: duration,
            delay: delay,
            easing: Math.random() > 0.5 ? 'ease-in-out' : (Math.random() > 0.5 ? 'ease-in' : 'cubic-bezier(0.17, 0.67, 0.83, 0.67)'), // Vary easing
            fill: 'forwards' // Keep end state after animation
        };

        // Create and play the animation
        const animation = particle.animate(keyframes, options);

        // --- Memory Management (Crucial!) ---
        // Remove the particle from the DOM when its animation finishes
        animation.onfinish = () => {
            // Check if the particle is still in the DOM before removing
            if (particle.parentNode) {
                particle.remove();
            }
        };
        // Handle cases where animation might be cancelled or fail
        animation.oncancel = () => {
             if (particle.parentNode) {
                particle.remove();
            }
        }

    } // End particle creation loop

    // --- CSS (Minimal - only base styles needed now) ---
    // Ensure the style element is added only once or updated correctly
    let styleElement = document.getElementById('particleStyles');
    if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = 'particleStyles';
        document.head.appendChild(styleElement);
    }

    // Define base styles for particles - animations are now handled by WAAPI
    // Note: We removed the @keyframes definitions as they are no longer used
    styleElement.textContent = `
        .particle {
            position: absolute;
            border-radius: 50%; /* Default shape */
            pointer-events: none; /* Particles should not interfere with interaction */
            will-change: transform, opacity; /* Hint browser about animation */
            /* filter: drop-shadow(0 0 2px currentColor); */ /* Example subtle glow - use carefully */
        }
    `;
}

// Initialize particles and set up auto-refresh
try {
    createParticles();
} catch (error) {
    console.error("Error initializing particles:", error);
}


// --- Refresh and Resize Handling ---
let particleRefreshInterval = null;
let particleResizeTimer = null;

function setupParticleTimers() {
    // Clear existing timers before setting new ones
    if (particleRefreshInterval) clearInterval(particleRefreshInterval);
    if (particleResizeTimer) clearTimeout(particleResizeTimer);

    // Refresh particles periodically only when tab is visible
    particleRefreshInterval = setInterval(() => {
        if (document.visibilityState === 'visible') {
             try {
                 createParticles();
             } catch (error) {
                 console.error("Error refreshing particles:", error);
             }
        }
    }, 60000); // Refresh every 60 seconds

    // Refresh on window resize (debounced)
    window.addEventListener('resize', () => {
        clearTimeout(particleResizeTimer);
        particleResizeTimer = setTimeout(() => {
             try {
                 createParticles();
             } catch (error) {
                 console.error("Error recreating particles on resize:", error);
             }
        }, 300); // Debounce resize event
    });
}

// Initial setup of timers
setupParticleTimers();









































    // Resize listener (Ensures WebGL viewport updates)
    window.addEventListener('resize', () => {
      if (gl && webglCanvas) { // Check if gl and canvas exist
        // The resizing and viewport update is handled within the render loop now for efficiency
      }
      // Could potentially recreate particles on resize if desired:
      // createParticles();
    });

  </script>

</body>
</html>
